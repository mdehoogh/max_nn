//* TITLE Auto-generated by Max External Definition Editor
/* delta2error.c */
// receives (error,M weights) lists from a total of N neurons
// M and N default to 1

#ifndef __LP64__
#define __LP64__ 1
#endif

//* TITLE END
//* INCLUDES Auto-generated by Max External Definition Editor
// ext.h should always be first, followed by ext_obex.h and any other files
#include "ext.h"
#include "ext_obex.h"

//* DEFINES END
//* STRUCTURE Auto-generated by Max External Definition Editor
// START structure definition
typedef struct delta2error {
	t_object d_ob;
	long d_N; // number of inputs
	long d_M; // number of outputs
	double d_LEARNING_RATE;
	double d_MOMENTUM;
	// a proxy for the remaining inlets
	void **d_proxiesptr;
	long d_in;
	void **d_outletsptr; // all the outlets
	double *d_sumsptr; // one sum for each output...
} t_delta2error;
//* STRUCTURE END
//* PROTOTYPES Auto-generated by Max External Definition Editor
static t_class *delta2error_class;

void *delta2error_new(long N, long M/*, double LEARNING_RATE, double MOMENTUM*/);
void delta2error_free(t_delta2error *x);

//* PROTOTYPES END
//* UTILITY FUNCTIONS Auto-generated by Max External Definition Editor
void delta2error_output_list(t_delta2error *x, short outlet_index, long argc, t_atom *args) {
	if (outlet_index>=0&&outlet_index<x->d_M)
		outlet_list(x->d_outletsptr[outlet_index],0L,argc,args);
	else
		object_error((t_object *)x,"Index (%ld) of outlet to output list invalid.",outlet_index);
}
//* UTILITY FUNCTIONS END
//* STANDARD MESSAGE HANDLERS Auto-generated by Max External Definition Editor
void delta2error_respond_to_info(t_delta2error *x, void *parent, void *container) {
	//* @TODO insert your code to handle the Max GetInfo() message here
	//* @TODO END
}
void delta2error_respond_to_preset(t_delta2error *x) {
	//* @TODO insert your code to handle the preset message here
	//* @TODO END
}
void delta2error_output_sums(t_delta2error *x) {
	// output the sums from right to left
	// MDH@02DEC2015: we need to also output the learning rate and momemtum (for updating the weights of the neuron the data goes to!!)
	t_atom updateatoms[3];
	atom_setfloat(updateatoms+1,x->d_LEARNING_RATE);
	atom_setfloat(updateatoms+2,x->d_MOMENTUM);
	// NOTE essential to clear the sums asap
	int i=x->d_M;
	while (--i>=0) {
		atom_setfloat(updateatoms,x->d_sumsptr[i]);
		x->d_sumsptr[i]=0.0;
		delta2error_output_list(x,i,3,updateatoms);
	}
	post("MdH >> Sums output.");
}
void delta2error_respond_to_loadbang(t_delta2error *x) {
	//////// NO don't do this here!!!! delta2error_output_sums(x);
	//////////post("Weights of neuron using function %s output.",x->a_FUNCTION->s_name);
}
void delta2error_respond_to_assist(t_delta2error *x, void *box, long msg, long arg, char *dst) {
	// inlet/outlet assistance automatically generated based on the inlet/outlet info texts
	if (msg==ASSIST_INLET) { // request for information about an inlet
		strcpy(dst,"error, weights, learning rate and momentum from (the second outlet of) the associated neuron in the layer");
	} else
  if (msg==ASSIST_OUTLET) { // request for information about an outlet
	  strcpy(dst,"the delta (sum), learning rate and momentum to input to the right-most inlet of the associated neuron in the layer before");
  }
}
void delta2error_respond_to_save(t_delta2error *x, void *dest) {
	// NOTE dest should be cast to a Binbuf object, and the appropriate header file describing Binbuf has to be included when doing so
	//* @TODO insert your code to handle the save message here
	//* @TODO END
}
//* STANDARD MESSAGE HANDLERS END
//* INLET MESSAGE HANDLERS Auto-generated by Max External Definition Editor
void delta2error_respond_to_bang(t_delta2error *x) {
	//* @TODO insert your code to handle the message here
	delta2error_output_sums(x);
	//* @TODO END
}
void delta2error_respond_to_list(t_delta2error *x, t_symbol *msg, long argc, t_atom *args) {
	int inlet_index=proxy_getinlet((t_object*)x);
	post("MdH >> Inlet: %ld.",inlet_index);
	// we can immediately update the sums using the first list elements as multiplicator, so when it's zero we do nothing
	// expecting the learning rate and momentum as well in the list BUT only those in the first inlet are important!!!
	if (argc>x->d_M) {
		double error=atom_getfloat(args); // the first argument represents the error multiplicator
		if (error!=0) {
			double weight;
			int i=x->d_M;
			// let's increment the sums
			while (i>0) {
				weight=atom_getfloat(args+i);
				i--;
				x->d_sumsptr[i]+=(error*weight);
			}
		} else
			post("MdH >> The error is zero.");
		// if this was the first inlet, output the sums...
		if (inlet_index==0)	{
			// for now use the last learning rate and momemtum provided (to replace whatever was set before)
			if (argc>x->d_M+1) {
				x->d_LEARNING_RATE=atom_getfloat(args+(x->d_M+1));
				if (argc>x->d_M+2) x->d_MOMENTUM=atom_getfloat(args+(x->d_M+2));
			}
			delta2error_output_sums(x);
		}
	} else
		object_error((t_object *)x,"Number of list elements (%ld) must exceed %ld.",argc,x->d_M);
}
//* MAIN Auto-generated by Max External Definition Editor
void ext_main(void *r) {
	// START setup
	t_class *c;
	c=class_new("delta2error",(method)delta2error_new,(method)delta2error_free,
				(short)sizeof(t_delta2error),NIL,A_LONG,A_LONG,/*A_DEFFLOAT,A_DEFFLOAT,*/A_NOTHING); // allocates class memory and sets up class
	// END setup
	
	// START message handler registration
	// standard message handlers
	class_addmethod(c,(method)delta2error_respond_to_assist,"assist",A_CANT,A_NOTHING);          // binding to assist message handler
	class_addmethod(c,(method)delta2error_respond_to_info,"info",A_CANT,A_NOTHING);          // binding to info message handler
	class_addmethod(c,(method)delta2error_respond_to_loadbang,"loadbang",A_CANT,A_NOTHING);          // binding to loadbang message handler
	class_addmethod(c,(method)delta2error_respond_to_preset,"preset",A_CANT,A_NOTHING);          // binding to preset message handler
	class_addmethod(c,(method)delta2error_respond_to_save,"save",A_CANT,A_NOTHING);          // binding to save message handler
	// specific message handlers
	class_addmethod(c,(method)delta2error_respond_to_bang,"bang",A_NOTHING);
	// END message handler registration
	// MDH@01NOV2015: don't forget A_GIMME!!!
	class_addmethod(c,(method)delta2error_respond_to_list,"list",A_GIMME,A_NOTHING);
	
	//* @TODO copy any resources here using rescopy or rescopyname
	/* SYNTAX:
	 void rescopy(OSType resType, short resID)
	 resType: The four character resource type of the resource you wish to copy.
	 resID  : The ID of the resource you wish to copy.
	 void resnamecopy(OSType resType, char *name)
	 resType: The four character resource type of the resource you wish to copy.
	 name   : A C string naming the resource you wish to copy.
	 */
	//* @TODO END
	finder_addclass("ANN","delta2error"); // the category to put the object into
	
	class_register(CLASS_BOX,c); // add this class to the CLASS_BOX namespace
	
	delta2error_class=c; // reference to class instance
}
//* MAIN END
//* NEW Auto-generated by Max External Definition Editor
/////////void *an_new(t_symbol *FUNCTION, long N, long M, double BIAS) {
void *delta2error_new(long N, long M/*, double LEARNING_RATE, double MOMENTUM*/) {
	t_delta2error *x; // the object to create and to be returned
	// allocate space for an instance of your class and initialize the object header
	x=(t_delta2error *)object_alloc(delta2error_class);
	if (N<1) {
		N=1; // default
		object_error((t_object *)x,"WARNING: The number of inlet values (first argument) should always be positive, and has been set to 1.");
	}
	// START creation of additional dynamic (proxy) inlets
	int i=N-1;
	if (i>0) {
		x->d_proxiesptr=sysmem_newptr(i*sizeof(void*)); // get memory to store the inlet proxy pointers
		while (--i>=0) x->d_proxiesptr[i]=proxy_new(x,i+1,x->d_in);
	} else
		x->d_proxiesptr=NULL;
	// END creation of additional dynamic inlets
	// no additional inlets to create
	
	// START creation of outlets
	int j=M;
	if (j>0) {
		x->d_outletsptr=sysmem_newptr(j*sizeof(void*)); // get memory to store the outlet pointers
		while (--j>=0) x->d_outletsptr[j]=listout(x);
	} else {
		x->d_outletsptr=NULL;
		object_error((t_object *)x,"The number of output values (second argument) should always be positive.");
	}
	// END creation of outlets
	
	// START process arguments
	// storing the arguments
	x->d_N=N;
	x->d_M=M;
	/*
	 x->d_LEARNING_RATE=LEARNING_RATE;
	 x->d_MOMENTUM=MOMENTUM;
	 */
	// END process arguments
	
	//* TODO initialization of additional x fields
	if (M>0) {
		x->d_sumsptr=sysmem_newptr(M*sizeof(double));
		while (--M>=0) x->d_sumsptr[M]=0.0;
	} else
		x->d_sumsptr=NULL;
	
	post("MdH >> delta2error version: 15 May 2017");
	
	//* TODO END
	return (x);
}
//* NEW END
//* FREE Auto-generated by Max External Definition Editor
void delta2error_free(t_delta2error *x) {
	//* @TODO enter memory release code here
	// how to release the proxy?????? I think it's automatic, if we declare it in a field!!!!
	if (x->d_sumsptr) sysmem_freeptr(x->d_sumsptr);
	if (x->d_outletsptr) sysmem_freeptr(x->d_outletsptr);
	if (x->d_proxiesptr) sysmem_freeptr(x->d_proxiesptr);
	//* @TODO END
}
//* FREE END

//* TITLE Auto-generated by Max External Definition Editor
/* an.c */

#ifndef __LP64__
#define __LP64__ 1
#endif

//* TITLE END
//* INCLUDES Auto-generated by Max External Definition Editor
// ext.h should always be first, followed by ext_obex.h and any other files
#include "ext.h"
#include "ext_obex.h"

//* INCLUDES END
//* DEFINES Auto-generated by Max External Definition Editor
#define NUMBER_OF_OUTLETS 5
/////////////enum t_mode {NORMAL,TRAIN}; // define the two possible modes!!!

//* DEFINES END
//* STRUCTURE Auto-generated by Max External Definition Editor
// START structure definition
typedef struct an {
	t_object a_ob;
	// we'll be using proxy dynamic inlets, so we will be able to find them back!!!
	// arguments
	t_symbol *a_FUNCTION;
	long a_N; // number of inputs
	unsigned long a_fixweightflags; // whether or not an associated weight should be adjusted in the back propagation training
	double a_BIAS;
	double a_MINWEIGHT;
	double a_MAXWEIGHT;
	short a_l; // so we can also use it to count what input we are expecting next!!!
	// a proxy for the second inlet!!!
	void *a_wproxy;
	void *a_uproxy;
	long a_in;
	void *a_outlets[NUMBER_OF_OUTLETS]; // static outlets
	void **a_proxies; // proxies for additional
	double *a_weightsptr; // weights
	// for training we need to remember the inputs as well as the delta weights (if momemtum>0)
	double *a_inputsptr; // inputs
	double *a_deltaweightsptr; // delta weights (to be used in computing the new delta weights), only when momemtum is not zero!!!!!
	double a_sum; // the last output value (to remember in order to be able to compute the error from a given delta)
	double a_output; // the last output value (to remember in order to be able to compute the error from a given delta)
	//* TODO END
} t_an;
//* STRUCTURE END
//* PROTOTYPES Auto-generated by Max External Definition Editor
static t_class *an_class;

/////void *an_new(t_symbol *FUNCTION, long N, double MINWEIGHT, double MAXWEIGHT, double BIAS, double DUMMY);
void *an_new(t_symbol *msg, long argc, t_atom *args);
void an_free(t_an *x);

//* PROTOTYPES END
//* UTILITY FUNCTIONS Auto-generated by Max External Definition Editor
void an_output_bang(t_an *x, short outlet_index) {
	if (outlet_index>=0&&outlet_index<NUMBER_OF_OUTLETS)
		outlet_bang(x->a_outlets[outlet_index]);
	else
		object_error((t_object *)x,"Index (%ld) of outlet to output bang invalid.",outlet_index);
}
void an_output_int(t_an *x, short outlet_index, long n) {
	if (outlet_index>=0&&outlet_index<NUMBER_OF_OUTLETS)
		outlet_int(x->a_outlets[outlet_index],n);
	else
		object_error((t_object *)x,"Index (%ld) of outlet to output integer %ld invalid.",outlet_index,n);
}
void an_output_float(t_an *x, short outlet_index, double f) {
	if (outlet_index>=0&&outlet_index<NUMBER_OF_OUTLETS)
		outlet_float(x->a_outlets[outlet_index],f);
	else
		object_error((t_object *)x,"Index (%ld) of outlet to output double %f invalid.",outlet_index,f);
}
void an_output_list(t_an *x, short outlet_index, short argc, t_atom *argv) {
	if (outlet_index>=0&&outlet_index<NUMBER_OF_OUTLETS)
		outlet_list(x->a_outlets[outlet_index],0L,argc,argv);
	else
		object_error((t_object *)x,"Index (%ld) of outlet to output list invalid.",outlet_index);
}
void an_output_anything(t_an *x, short outlet_index, t_symbol *msg, short argc, t_atom *argv) {
	if (outlet_index>=0&&outlet_index<NUMBER_OF_OUTLETS)
		outlet_anything(x->a_outlets[outlet_index],msg,argc,argv);
	else
		object_error((t_object *)x,"Index (%ld) of outlet to output a message invalid.",outlet_index);
}
//* UTILITY FUNCTIONS END
//* STANDARD MESSAGE HANDLERS Auto-generated by Max External Definition Editor
void an_respond_to_info(t_an *x, void *parent, void *container) {
	//* @TODO insert your code to handle the Max GetInfo() message here
	//* @TODO END
}
void an_respond_to_preset(t_an *x) {
	//* @TODO insert your code to handle the preset message here
	post("MdH >> Preset message received.");
	//* @TODO END
}
// MDH@16MAY2017: we'd like to be able to output all parts used in computing the delta weights
void an_output_adjustment_info(t_an *x, double error, double derivative, double delta, double learning_rate, double momentum) {
	int wc=x->a_N+(x->a_BIAS!=0);
	int l=3*wc+14;
	int offset=0;
	t_atom infoatoms[l]; // outputting the inputs, initial weights, output
	atom_setsym(infoatoms+(offset++),gensym("I"));
	for (int i=0;i<wc;i++) atom_setfloat(infoatoms+(offset++),x->a_inputsptr[i]); // wc elements
	atom_setsym(infoatoms+(offset++),gensym("S"));	atom_setfloat(infoatoms+(offset++),x->a_sum);
	atom_setsym(infoatoms+(offset++),gensym("O"));	atom_setfloat(infoatoms+(offset++),x->a_output);
	atom_setsym(infoatoms+(offset++),gensym("E"));	atom_setfloat(infoatoms+(offset++),error);
	atom_setfloat(infoatoms+(offset++),learning_rate); atom_setfloat(infoatoms+(offset++),momentum); // MDH@13MAY2017
	atom_setsym(infoatoms+(offset++),gensym("D"));	atom_setfloat(infoatoms+(offset++),derivative); // append the derivative as well
	atom_setfloat(infoatoms+(offset++),delta); // 'prepend' the current delta value!!
	atom_setsym(infoatoms+(offset++),gensym("DW"));	for (int i=0;i<wc;i++) atom_setfloat(infoatoms+(offset++),x->a_deltaweightsptr[i]);
	atom_setsym(infoatoms+(offset++),gensym("W"));	for (int i=0;i<wc;i++) atom_setfloat(infoatoms+(offset++),x->a_weightsptr[i]);
	an_output_list(x,4,l,infoatoms); // output the (delta,weights) in the second outlet
}
// MDH@01DEC2015: we never output weights by themselves i.e. we always start with outputting the error value
void an_output_weights(t_an *x, double delta, double learning_rate, double momentum) {
	// this is a problem in that we need to construct a weights message
	// MDH@13MAY2017: TODO should we or should we not output the weight associated with the bias????
	int wc=x->a_N; /////////////+(x->a_BIAS!=0);
	t_atom weightatoms[wc+3]; // we need an additional item to store the delta value in
	atom_setfloat(weightatoms,delta); // 'prepend' the current delta value!!
	double w; for (int i=0;i<wc;) { w=x->a_weightsptr[i]; i++; atom_setfloat(weightatoms+i,w); }
	atom_setfloat(weightatoms+(wc+1),learning_rate); atom_setfloat(weightatoms+(wc+2),momentum); // MDH@13MAY2017
	an_output_list(x,1,wc+3,weightatoms); // output the (delta,weights) in the second outlet
	/////////post("MdH >> Delta, weights, learning rate, momentum and derivative output.");
}
void an_output_state(t_an *x) {
	// we're going to output N, FUNCTION, BIAS followed by all the weights!!!
	t_atom parameteratoms[4]; // we're outputting the function and parameters in the third outlet
	atom_setlong(parameteratoms,x->a_N); atom_setlong(parameteratoms+1,x->a_BIAS);
	atom_setfloat(parameteratoms+2,x->a_MINWEIGHT); atom_setfloat(parameteratoms+3,x->a_MAXWEIGHT);
	an_output_anything(x,2,x->a_FUNCTION,4,parameteratoms);
	// and now the weights (prefixed with W)
	int wc=x->a_N+(x->a_BIAS!=0);
	t_atom weightatoms[wc]; // let's output the delta weights as well
	// setting the weights
	for (int i=0;i<wc;i++) atom_setfloat(weightatoms+i,x->a_weightsptr[i]);
	// let's output the weights as a list
	an_output_list(x,3,wc,weightatoms);
	for (int i=0;i<wc;i++) atom_setfloat(weightatoms+i,x->a_deltaweightsptr[i]);
	an_output_list(x,4,wc,weightatoms);
	////////post("MdH >> Activation function, number of inputs, bias, minimum and maximum weight output in third outlet, weights and delta weights in fourth and fifth outlet.");
}
void an_respond_to_loadbang(t_an *x) {
	//////////post("Weights of neuron using function %s output.",x->a_FUNCTION->s_name);
}
void an_respond_to_assist(t_an *x, void *box, long msg, long arg, char *dst) {
	// inlet/outlet assistance automatically generated based on the inlet/outlet info texts
	if (msg==ASSIST_INLET) { // request for information about an inlet
		if (x->a_l<0) { // list input
			switch (arg) {
				case 0:
					strcpy(dst,"a list of input values (from the layer above)");
					break;
				case 1:
					strcpy(dst,"a list with the error value, learning rate and momentum");
					break;
			}
		} else { // every input value its own inlet
			if (arg==0) {
				strcpy(dst,"the first input value to receive last that produces the (output) value that is send out the first outlet");
			} else
				if (arg>=x->a_N) { // the right-most inlet
					strcpy(dst,"a list with the error value, learning rate and (optional) momentum");
				} else // it's a gamble to use sprintf here
					sprintf(dst,"input value #%ld",(arg+1));
		}
	} else
		if (msg==ASSIST_OUTLET) { // request for information about an outlet
			switch (arg) {
				case 0:
					if (x->a_l<0)
						strcpy(dst,"the output value produced when the first inlet receives the list of input values");
					else
						strcpy(dst,"the output value produced when the first inlet receives its input value");
					break;
				case 1:
					strcpy(dst,"the delta followed by the weights produced from error, learning rate and (optionally) momentum received in the right-most inlet");
					break;
				case 2:
					strcpy(dst,"the parameters of the neuron (activation function, number of inputs, bias flag, minimum and maximum weight) produced when a bang is received");
					break;
				case 3:
					strcpy(dst,"the weights of the neuron produced when a bang is received");
					break;
			}
		}
}
void an_respond_to_save(t_an *x, void *dest) {
	// NOTE dest should be cast to a Binbuf object, and the appropriate header file describing Binbuf has to be included when doing so
	//* @TODO insert your code to handle the save message here
	//* @TODO END
}
//* STANDARD MESSAGE HANDLERS END
//* INLET MESSAGE HANDLERS Auto-generated by Max External Definition Editor
void an_respond_to_bang(t_an *x) {
	//* @TODO insert your code to handle the message here
	an_output_state(x); // MDH@01DEC2015: prefixing 0.0 for error will NOT change the sums in the deltagenerator
	//* @TODO END
}
//* INLET MESSAGE HANDLERS END
void an_output_value(t_an *x, double sum) {
	// apply the function on the sum (if the output value is unknown we'll be using unity function
	x->a_sum=sum; // remember the sum
	if (x->a_FUNCTION==gensym("A"))
		x->a_output=atan(sum);
	else
		if (x->a_FUNCTION==gensym("T"))
			x->a_output=tanh(sum);
		else
			if (x->a_FUNCTION==gensym("L")) // logistic sigmoid function
				x->a_output=(1/(1+exp(-sum)));
			else
				if (x->a_FUNCTION==gensym("S")) // unit step function
					x->a_output=(sum<0?-1:(sum>0?1:0));
				else
					x->a_output=sum;
	// and push it out the first outlet
	an_output_float(x,0,x->a_output);
}
// MDH@04NOV2015: we only need either a list of new weights, or a bang to output the weights (so there's no mode anymore!!!)
void an_respond_to_int(t_an *x, long n) {
	if (n>=0) {
		x->a_fixweightflags=n;
		post("MdH >> Fix weight flags set to %ld.",x->a_fixweightflags);
	} else
		object_error((t_object*)x,"The fix weight flags integer should be a nonnegative.");
}
/*
 void an_respond_to_anything(t_an *x, t_symbol *msg, long argc, t_atom *args) {
	if (msg==gensym("M"))
 an_respond_to_int_in_mode(x,atom_getlong(args));
	else
	if (msg==gensym("W")) {
 if (argc==x->a_N) {
 while (--argc>=0) x->a_weightsptr[argc]=atom_getfloat(args+argc);
 output_weights(x); // output the weights received again!!!
 } else
 object_error((t_object *)x,"Number of weights (%ld) not equal to %ld.",argc,x->a_N);
	} else
 object_error((t_object *)x,"Unknown message %s received (only M and W allowed).",msg->s_name);
 }
 */
// an_derivative computes the derivative of the output value which depends on the activation function!!!
double an_derivative(t_an *x) {
	if (x->a_FUNCTION==gensym("L")) return x->a_output*(1-x->a_output);
	if (x->a_FUNCTION==gensym("T")) return 1-(x->a_output*x->a_output);
	/*
	 if (x->a_FUNCTION==gensym("A")) return 0.0;
	 if (x->a_FUNCTION==gensym("S")) return 0.0; // unit step function
	 */
	return 0.0;
}
// we want to compute the sum and then output it
void an_process_input(t_an *x){
	// NOTE the weight at index 0 represents the (trainable) bias
	double sum=0; int i=x->a_N+(x->a_BIAS!=0); while (--i>=0) sum+=x->a_weightsptr[i]*x->a_inputsptr[i];
	an_output_value(x,sum); // output the value
}
void an_respond_to_list(t_an *x, t_symbol *msg, long argc, t_atom *args) {
	// either the input values (inlet 0) or weights (inlet 1)
	int inlet_index=proxy_getinlet((t_object*)x);
	///////post("MdH >> List received in inlet: %ld.",inlet_index);
	int correctionlist_index=(x->a_l<0)?1:x->a_N;
	// a list is only allowed when operating in list mode or when the inlet index is the correction list index
	if (x->a_l<0||inlet_index>=correctionlist_index) {
		if (inlet_index==0) { // N input values
			if (argc>=x->a_N) { // at least x->a_N weights required!!!!
				// compute the weighted sum of the first x->a_N input values (don't forget the BIAS as initial value for x->sum!!!)
				argc=x->a_N; // we do NOT want to use additional input values (and overwrite the fixed bias value!!!)
				while (--argc>=0) x->a_inputsptr[argc]=atom_getfloat(args+argc); // remember the input, consuming argc in the process!!
				an_process_input(x); // process the input
			} else
				object_error((t_object *)x,"Number of input values (%ld) specified not equal to %ld.",argc,x->a_N);
		} else { // must be the correction list index (in the right-most inlet)
			if (inlet_index==correctionlist_index) {
				// error + learning rate + momentum
				if (argc>=2) { // at least error + learning rate required
					double error=atom_getfloat(args);
					double learning_rate=atom_getfloat(args+1);
					double momentum=0; if (argc>2) momentum=atom_getfloat(args+2);
					// using error we can compute the delta (assuming x->a_output is defined)
					double derivative=an_derivative(x);
					double delta=derivative*error;
					// we're outputting the delta and the weights here for processing by a delta2error object
					// which is different from collecting all results from this adjustment phase
					an_output_weights(x,delta,learning_rate,momentum); // MDH@13MAY2017: pass out learning rate and momentum as well
					// using the learning rate and the momentum we can update the weights
					double deltaweight;
					int i=x->a_N+(x->a_BIAS!=0); // adapt the bias (weight) in the same loop
					while (--i>=0) {
						// here we should test whether or not the given weight is to adjustable
						if (((x->a_fixweightflags>>i)&1)==0) {
							deltaweight=learning_rate*delta*x->a_inputsptr[i]; // MDH@01DEC2015: should we also multiply by the input value?????
							if (momentum>0) deltaweight+=momentum*x->a_deltaweightsptr[i];
							x->a_deltaweightsptr[i]=deltaweight;
							x->a_weightsptr[i]+=x->a_deltaweightsptr[i];
						} else
							post("MdH >> WARNING: %s not adjusted!",(i==x->a_N)?"Bias weight":"Weight #%ld",(i+1));
					}
					/* adjust the weights: already done!!!!
					 i=x->a_N+(x->a_BIAS!=0);  while (--i>=0) x->a_weightsptr[i]+=x->a_deltaweightsptr[i];
					 */
					an_output_adjustment_info(x,error,derivative,delta,learning_rate,momentum);
				} else
					object_error((t_object *)x,"At least the error and learning rate are required.");
			} else { // weights inlet
				// what we can do here is if a bias is specified assume it is supposedly fixed (as in Matt Mazur's example)
				// normally, we would choose random weights (and a fixed but adaptable bias which defaults to 1)
				// alternatively we could set a mask on which weights should be mutable, which should be an int
				int i=x->a_N+(x->a_BIAS!=0);
				if (argc>=i) {
					while (--i>=0) x->a_weightsptr[i]=atom_getfloat(args+i); // remember the input, consuming argc in the process!!
				} else
					object_error((t_object *)x,"Not enough weights specified.");
			}
		}
	} else
		object_error((t_object *)x,"Only the last inlet (or the first in list mode) may receive a list.");
}
// all proxy inlets are supposed to be able to process floats but we need to know which ones
void an_respond_to_float(t_an *x, double f) {
	int inlet_index=proxy_getinlet((t_object*)x);
	if (inlet_index<x->a_N) { // not the right-most inlet (therefore an input value inlet)
		if (x->a_l>0) { // non-list mode, we need to update the input value index, and check whether it matches the inlet index
			x->a_l--; // decrement the expected input value index
			if (inlet_index!=x->a_l) { // incorrect inlet
				//////post("MdH >> Inlet=%ld - Expected input index=%d.",inlet_index,x->a_l);
				x->a_l=x->a_N; // resetting the input index
				object_error((t_object *)x,"MdH >> Input value received out of order. Please start over entering the input values.");
				return;
			}
			// if we get here data was valid
			x->a_inputsptr[inlet_index]=f; // store the input value
			if (inlet_index==0) { // last expected input value receieved, input value list complete, and ready to be processed...
				x->a_l=x->a_N; // reset the expected input index
				an_process_input(x); // process the input
			}
		} else { // list mode
			// allowed in case a single input value is expected!!!
			if (x->a_N==1) { // turn it into a list, and process it as if it was a list
				t_atom atoms[1]; atom_setfloat(atoms,f);
				an_respond_to_list(x,NULL,1,atoms);
			} else
				object_error((t_object *)x,"MdH >> A single input value is not allowed: expecting %ld input values.",x->a_N);
		}
	} else // a single float does NOT suffice
		object_error((t_object *)x,"MdH >> At least error and learning rate are required (the third argument representing the momentum is optional and defaults to 0).");
}
//* MAIN Auto-generated by Max External Definition Editor
void ext_main(void *r) {
	// START setup
	t_class *c;
	c=class_new("an",(method)an_new,(method)an_free,(short)sizeof(t_an),NIL,A_GIMME,A_NOTHING); // allocates class memory and sets up class
	// END setup
	
	// START message handler registration
	// standard message handlers
	class_addmethod(c,(method)an_respond_to_assist,"assist",A_CANT,A_NOTHING);          // binding to assist message handler
	class_addmethod(c,(method)an_respond_to_info,"info",A_CANT,A_NOTHING);          // binding to info message handler
	class_addmethod(c,(method)an_respond_to_loadbang,"loadbang",A_CANT,A_NOTHING);          // binding to loadbang message handler
	class_addmethod(c,(method)an_respond_to_preset,"preset",A_CANT,A_NOTHING);          // binding to preset message handler
	class_addmethod(c,(method)an_respond_to_save,"save",A_CANT,A_NOTHING);          // binding to save message handler
	// specific message handlers
	class_addmethod(c,(method)an_respond_to_bang,"bang",A_NOTHING);
	// END message handler registration
	class_addmethod(c,(method)an_respond_to_float,"float",A_FLOAT,A_NOTHING);
	// MDH@01NOV2015: don't forget A_GIMME!!!
	class_addmethod(c,(method)an_respond_to_list,"list",A_GIMME,A_NOTHING);
	class_addmethod(c,(method)an_respond_to_int,"int",A_LONG,A_NOTHING); // we want to be able to set the fixate weight flags
	
	//* @TODO copy any resources here using rescopy or rescopyname
	/* SYNTAX:
	 void rescopy(OSType resType, short resID)
	 resType: The four character resource type of the resource you wish to copy.
	 resID  : The ID of the resource you wish to copy.
	 void resnamecopy(OSType resType, char *name)
	 resType: The four character resource type of the resource you wish to copy.
	 name   : A C string naming the resource you wish to copy.
	 */
	//* @TODO END
	finder_addclass("ANN","an"); // the category to put the object into
	
	class_register(CLASS_BOX,c); // add this class to the CLASS_BOX namespace
	
	srand((unsigned int)time(NULL)); // MDH@01DEC2015: initialize the random seed of the (pseudo)random number generator
	
	an_class=c; // reference to class instance
}
//* MAIN END
void an_free_weights(t_an *x) {
	if (x->a_weightsptr) sysmem_freeptr(x->a_weightsptr);
	if (x->a_inputsptr) sysmem_freeptr(x->a_inputsptr);
	if (x->a_deltaweightsptr) sysmem_freeptr(x->a_deltaweightsptr);
}
void an_initialize(t_an *x) {
	//* TODO initialization of additional x fields
	int wc=x->a_N+(x->a_BIAS!=0); // total number of weights
	if (wc>0) {
		post("MdH >> Initializing artificial neuron.");
		post("MdH >>     Number of inputs: %ld.",x->a_N);
		post("MdH >>     Function: %s.",x->a_FUNCTION->s_name);
		post("MdH >>     Bias (weight): %f.",x->a_BIAS);
		int i;
		x->a_weightsptr=sysmem_newptr(wc*sizeof(double));
		if (x->a_BIAS!=0) x->a_weightsptr[x->a_N]=x->a_BIAS; // it's easier to put the bias weight at the end!!!!
		post("MdH >>     Setting %ld weights to random numbers in [%f,%f].",x->a_N,x->a_MINWEIGHT,x->a_MAXWEIGHT);
		// get a random number in (MINWEIGHT,MAXWEIGHT)
		double w,wrange=x->a_MAXWEIGHT-x->a_MINWEIGHT;
		i=x->a_N; while (--i>=0) { w=x->a_MINWEIGHT; if (wrange>0) w+=rand()*wrange; x->a_weightsptr[i]=w; }
		x->a_deltaweightsptr=sysmem_newptr(wc*sizeof(double));
		i=wc; while (--i>=0) x->a_deltaweightsptr[i]=0.0;
		// we only have N inputs (not N+x->a_BIAS) but we set the last input to 1 fixed!!!
		x->a_inputsptr=sysmem_newptr(wc*sizeof(double));
		if (x->a_BIAS!=0) x->a_inputsptr[x->a_N]=1.0; // fixed value for the dummy bias input!!
	} else {
		post("MdH >> WARNING: Artificial neuron with no inputs!");
		x->a_weightsptr=NULL;
		x->a_inputsptr=NULL;
		x->a_deltaweightsptr=NULL;
	}
}
// resetting means free all memory to dynamically allocated things!!!
void an_reset(t_an *x) {
	an_free_weights(x);
	an_initialize(x);
}
//* NEW Auto-generated by Max External Definition Editor
/////////void *an_new(t_symbol *FUNCTION, long N, long M, double BIAS) {
//////void *an_new(t_symbol *FUNCTION, long N, double MINWEIGHT, double MAXWEIGHT, double BIAS, double DUMMY) {
void *an_new(t_symbol *msg, long argc, t_atom *args) {
	t_an *x; // the object to create and to be returned
	// allocate space for an instance of your class and initialize the object header
	x=(t_an *)object_alloc(an_class);
	// extract arguments, by default all the weights and biases are set to 1
	long N=1; double MINWEIGHT=1.0,MAXWEIGHT=1.0,BIAS=1.0; t_symbol *FUNCTION=gensym("L");
	///////post("Number of arguments: %ld.",args);
	x->a_l=0; // assume by default NO list input (so one inlet per input value)
	if (argc>0) {
		// if we do the function first (being a symbol), we can use l to indicate a layered artificial neuron and make it optional
		// I suppose we could do N first, because that's the most likely value to set
		N=atom_getlong(args);
		if (argc>1) {
			// the other parameters can then shift up!!!
			t_symbol *SYMBOL_ARGUMENT=atom_getsym(args+1);
			// if the second argument symbol is NOT lowercase l, we assume it's the transition function
			if (SYMBOL_ARGUMENT==gensym("l")) {
				x->a_l=-1;
				if (argc>2) FUNCTION=atom_getsym(args+2); // if a function is specified get it
			} else // this argument is the function
				FUNCTION=SYMBOL_ARGUMENT; // whether or not list input!!!
			/////post("FUNCTION: %s.",FUNCTION);
			if (argc>2+x->a_l) {
				MINWEIGHT=atom_getfloat(args+(2+x->a_l));
				///////post("MINWEIGHT: %f.",MINWEIGHT);
				if (argc>3+x->a_l) {
					MAXWEIGHT=atom_getfloat(args+(3+x->a_l));
					//post("MAXWEIGHT: %f.",MAXWEIGHT);
					if (argc>4+x->a_l) {
						BIAS=atom_getfloat(args+(4+x->a_l));
						//post("BIAS: %f.",BIAS);
					}
				}
			}
		}
	}
	// argument processing...
	if (N<1) {
		N=1; // default
		object_error((t_object *)x,"WARNING: The number of inlet values (first argument) should always be positive, and has been set to 1.");
	}
	
	// create the proxy for the correction inlet (apparently one for each additional inlet)
	// we're using N+1 so that it's easy to distinguish from the input inlets
	x->a_wproxy=proxy_new(x,N+1,&x->a_in); // MDH@15MAY2017: for allowing to set the weights!!!
	x->a_uproxy=proxy_new(x,N,&x->a_in); // adding another proxy inlet with index N (we're using 0..N-1 for input)
	
	if(x->a_l==0) { // non list mode, so we have to create N-1 additional inlets
		x->a_l=N; // initialize to the total number of inputs, so we'll be ready to receive input immediately...
		short i=x->a_l-1;
		if (i>0) { // no list input, so one float per inlet
			x->a_proxies=sysmem_newptr(i*sizeof(void*)); // get memory to store the inlet proxy pointers
			while (--i>=0) x->a_proxies[i]=proxy_new(x,i+1,&x->a_in); // TODO would it work correctly without the & in front of x->a_in?????
		}
	}
	
	/*
  // START creation of additional dynamic (proxy) inlets
	 if (N>0) {
		x->a_proxies=sysmem_newptr(N*sizeof(void*)); // get memory to store the inlet proxy pointers
		int i=N; while (--i>=0) x->a_proxies[i]=proxy_new(x,i,x->a_in);
	 } else
		object_error((t_object *)x,"The number of inlet values (second argument) should always be positive.");
	 */
	// END creation of additional dynamic inlets
	// no additional inlets to create
	
	// START creation of outlets
	x->a_outlets[4]=listout(x); // the delta weights are output as a list
	x->a_outlets[3]=listout(x); // the weights are output as a list
	x->a_outlets[2]=outlet_new(x,NULL); // we'd like a message outlet (e.g. to report parameters!!!)
	x->a_outlets[1]=listout(x); // will output the error + weights (to pass to the delta generator)
	x->a_outlets[0]=floatout(x); // will output a real value
	// END creation of outlets
	
	// START process arguments
	// storing the arguments
	/// x->a_ID=ID;
	x->a_FUNCTION=FUNCTION;
	x->a_N=N;
	// if we want to be able to reset the lot we have to remember all arguments!!!
	x->a_MINWEIGHT=MINWEIGHT;
	x->a_MAXWEIGHT=MAXWEIGHT;
	x->a_BIAS=BIAS; // if a bias argument not equal to zero is defined, we will set the first weight to the bias component!!!
	// END process arguments
	
	an_initialize(x);
	
	//* TODO END
	return (x);
}
//* NEW END
//* FREE Auto-generated by Max External Definition Editor
void an_free(t_an *x) {
	//* @TODO enter memory release code here
	// how to release the proxy?????? I think it's automatic, if we declare it in a field!!!!
	an_free_weights(x);
	sysmem_freeptr(x->a_wproxy);
	sysmem_freeptr(x->a_uproxy);
	if (x->a_proxies) sysmem_freeptr(x->a_proxies);
	//* @TODO END
}
//* FREE END

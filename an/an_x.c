//* TITLE Auto-generated by Max External Definition Editor
/* an.c */

//* TITLE END
//* INCLUDES Auto-generated by Max External Definition Editor
// ext.h should always be first, followed by ext_obex.h and any other files
#include "ext.h"
#include "ext_obex.h"

//* INCLUDES END
//* DEFINES Auto-generated by Max External Definition Editor
#define NUMBER_OF_OUTLETS 3
/////////////enum t_mode {NORMAL,TRAIN}; // define the two possible modes!!!

//* DEFINES END
//* STRUCTURE Auto-generated by Max External Definition Editor
// START structure definition
typedef struct an {
	t_object a_ob;
	// we'll be using proxy dynamic inlets, so we will be able to find them back!!!
	// arguments
	t_symbol *a_FUNCTION;
	long a_N; // number of inputs
	double a_BIAS;
	double a_MINWEIGHT;
	double a_MAXWEIGHT;
	char a_l;
	// a proxy for the second inlet!!!
	void *a_proxy;
	long a_in;
	void *a_outlets[NUMBER_OF_OUTLETS]; // static outlets
	void **a_proxies; // proxies for additional
	double *a_weightsptr; // weights
	// for training we need to remember the inputs as well as the delta weights (if momemtum>0)
	double *a_inputsptr; // inputs
	double *a_deltaweightsptr; // delta weights (to be used in computing the new delta weights), only when momemtum is not zero!!!!!
	double a_output; // the last output value (to remember in order to be able to compute the error from a given delta)
	//* TODO END
} t_an;
//* STRUCTURE END
//* PROTOTYPES Auto-generated by Max External Definition Editor
static t_class *an_class;

/////void *an_new(t_symbol *FUNCTION, long N, double MINWEIGHT, double MAXWEIGHT, double BIAS, double DUMMY);
void *an_new(t_symbol *msg, long argc, t_atom *args);
void an_free(t_an *x);

//* PROTOTYPES END
//* UTILITY FUNCTIONS Auto-generated by Max External Definition Editor
void an_output_bang(t_an *x, short outlet_index) {
	if (outlet_index>=0&&outlet_index<NUMBER_OF_OUTLETS)
		outlet_bang(x->a_outlets[outlet_index]);
	else
		object_error((t_object *)x,"Index (%ld) of outlet to output bang invalid.",outlet_index);
}
void an_output_int(t_an *x, short outlet_index, long n) {
	if (outlet_index>=0&&outlet_index<NUMBER_OF_OUTLETS)
		outlet_int(x->a_outlets[outlet_index],n);
	else
		object_error((t_object *)x,"Index (%ld) of outlet to output integer %ld invalid.",outlet_index,n);
}
void an_output_float(t_an *x, short outlet_index, double f) {
	if (outlet_index>=0&&outlet_index<NUMBER_OF_OUTLETS)
		outlet_float(x->a_outlets[outlet_index],f);
	else
		object_error((t_object *)x,"Index (%ld) of outlet to output double %f invalid.",outlet_index,f);
}
void an_output_list(t_an *x, short outlet_index, short argc, t_atom *argv) {
	if (outlet_index>=0&&outlet_index<NUMBER_OF_OUTLETS)
		outlet_list(x->a_outlets[outlet_index],0L,argc,argv);
	else
		object_error((t_object *)x,"Index (%ld) of outlet to output list invalid.",outlet_index);
}
void an_output_anything(t_an *x, short outlet_index, t_symbol *msg, short argc, t_atom *argv) {
	if (outlet_index>=0&&outlet_index<NUMBER_OF_OUTLETS)
		outlet_anything(x->a_outlets[outlet_index],msg,argc,argv);
	else
		object_error((t_object *)x,"Index (%ld) of outlet to output a message invalid.",outlet_index);
}
//* UTILITY FUNCTIONS END
//* STANDARD MESSAGE HANDLERS Auto-generated by Max External Definition Editor
void an_respond_to_info(t_an *x, void *parent, void *container) {
	//* @TODO insert your code to handle the Max GetInfo() message here
	//* @TODO END
}
void an_respond_to_preset(t_an *x) {
	//* @TODO insert your code to handle the preset message here
	//* @TODO END
}
// MDH@01DEC2015: we never output weights by themselves i.e. we always start with outputting the error value
void an_output_weights(t_an *x, double delta) {
	// this is a problem in that we need to construct a weights message
	int wc=x->a_N+(x->a_BIAS!=0);
	t_atom weightatoms[wc+1]; // we need an additional item to store the delta value in
	double w; for (int i=0;i<wc;) { w=x->a_weightsptr[i]; i++; atom_setfloat(weightatoms+i,w); }
	atom_setfloat(weightatoms,delta); // 'prepend' the current delta value!!
	an_output_list(x,1,wc+1,weightatoms); // output the (delta,weights) in the second outlet
	post("Delta and weights output.");
}
void an_output_state(t_an *x) {
	// we're going to output N, FUNCTION, BIAS followed by all the weights!!!
	int wc=x->a_N+(x->a_BIAS!=0);
	t_atom stateatoms[wc+2];
	atom_setlong(stateatoms,x->a_N); atom_setlong(stateatoms+1,x->a_BIAS);
	// appending the weights
	for (int i=0;i<wc;i++) atom_setfloat(stateatoms+i+2,x->a_weightsptr[i]);
	// we could make the msg the function of the neuron
	an_output_anything(x,2,x->a_FUNCTION,wc+2,stateatoms);
}
void an_respond_to_loadbang(t_an *x) {
	an_output_state(x); // MDH@01DEC2015: prefixing 0.0 for error will NOT change the sums in the deltagenerator
	//////////post("Weights of neuron using function %s output.",x->a_FUNCTION->s_name);
}
void an_respond_to_assist(t_an *x, void *box, long msg, long arg, char *dst) {
	// inlet/outlet assistance automatically generated based on the inlet/outlet info texts
	if (msg==ASSIST_INLET) { // request for information about an inlet
		switch (arg) {
			case 0:
				strcpy(dst,"a list of N input values (N=first argument)");
				break;
			case 1:
				strcpy(dst,"a list consisting of the error value, the leaning rate, and the momentum");
				break;
		}
	} else
		if (msg==ASSIST_OUTLET) { // request for information about an outlet
			switch (arg) {
				case 0:
					strcpy(dst,"the output value");
					break;
				case 1:
					strcpy(dst,"a list starting with the delta followed by the weights");
					break;
				case 2:
					strcpy(dst,"the current state of the neuron (number of inputs, bias flag, input weights)");
					break;
			}
		}
}
void an_respond_to_save(t_an *x, void *dest) {
	// NOTE dest should be cast to a Binbuf object, and the appropriate header file describing Binbuf has to be included when doing so
	//* @TODO insert your code to handle the save message here
	//* @TODO END
}
//* STANDARD MESSAGE HANDLERS END
//* INLET MESSAGE HANDLERS Auto-generated by Max External Definition Editor
void an_respond_to_bang(t_an *x) {
	//* @TODO insert your code to handle the message here
	an_respond_to_loadbang(x); // same as loadbang
	//* @TODO END
}
//* INLET MESSAGE HANDLERS END
void an_output_value(t_an *x, double sum) {
	// apply the function on the sum (if the output value is unknown we'll be using unity function
	if (x->a_FUNCTION==gensym("A"))
		x->a_output=atan(sum);
	else
		if (x->a_FUNCTION==gensym("T"))
			x->a_output=tanh(sum);
		else
			if (x->a_FUNCTION==gensym("L")) // logistic sigmoid function
				x->a_output=(1/(1+exp(-sum)));
			else
				if (x->a_FUNCTION==gensym("S")) // unit step function
					x->a_output=(sum<0?-1:(sum>0?1:0));
				else
					x->a_output=sum;
	// and push it out the first outlet
	an_output_float(x,0,x->a_output);
}
// MDH@04NOV2015: we only need either a list of new weights, or a bang to output the weights (so there's no mode anymore!!!)
/*
 void an_respond_to_int_in_mode(t_an *x, long n) {
	// when switching to normal mode ALWAYS set the sum to 0
	if (n!=TRAIN) { x->mode=NORMAL; x->sum=0; } else x->mode=TRAIN;
	output_mode(x); // output the current mode immediately
 }
 void an_respond_to_anything(t_an *x, t_symbol *msg, long argc, t_atom *args) {
	if (msg==gensym("M"))
 an_respond_to_int_in_mode(x,atom_getlong(args));
	else
	if (msg==gensym("W")) {
 if (argc==x->a_N) {
 while (--argc>=0) x->a_weightsptr[argc]=atom_getfloat(args+argc);
 output_weights(x); // output the weights received again!!!
 } else
 object_error((t_object *)x,"Number of weights (%ld) not equal to %ld.",argc,x->a_N);
	} else
 object_error((t_object *)x,"Unknown message %s received (only M and W allowed).",msg->s_name);
 }
 */
// an_derivative computes the derivative of the output value which depends on the activation function!!!
double an_derivative(t_an *x) {
	if (x->a_FUNCTION==gensym("L")) return x->a_output*(1-x->a_output);
	if (x->a_FUNCTION==gensym("T")) return 1-(x->a_output*x->a_output);
	/*
	 if (x->a_FUNCTION==gensym("A")) return 0.0;
	 if (x->a_FUNCTION==gensym("S")) return 0.0; // unit step function
	 */
	return 0.0;
}
// we want to compute the sum and then output it
void an_process_input(t_an *x){
	// NOTE the weight at index 0 represents the (trainable) bias
	double sum=0; int i=x->a_N+(x->a_BIAS!=0); while (--i>=0) sum+=x->a_weightsptr[i]*x->a_inputsptr[i];
	an_output_value(x,sum); // output the value
}
void an_respond_to_list(t_an *x, t_symbol *msg, long argc, t_atom *args) {
	// either the input values (inlet 0) or weights (inlet 1)
	int inlet_index=proxy_getinlet((t_object*)x);
	post("Inlet: %ld.",inlet_index);
	switch (inlet_index) {
		case 0: // N input values
			if (argc>=x->a_N) { // at least x->a_N weights required!!!!
				// compute the weighted sum of the first x->a_N input values (don't forget the BIAS as initial value for x->sum!!!)
				argc=x->a_N; // we do NOT want to use additional input values (and overwrite the fixed bias value!!!)
				while (--argc>=0) x->a_inputsptr[argc]=atom_getfloat(args+argc); // remember the input, consuming argc in the process!!
				an_process_input(x); // process the input
			} else
				object_error((t_object *)x,"Number of input values (%ld) specified not equal to %ld.",argc,x->a_N);
			break;
		case 1: // error + learning rate + momentum
			if (argc>=2) { // at least error + learning rate required
				double error=atom_getfloat(args);
				double learning_rate=atom_getfloat(args+1);
				double momentum=0;
				if (argc>2) momentum=atom_getfloat(args+2);
				// using error we can compute the delta (assuming x->a_output is defined)
				double delta=an_derivative(x)*error;
				an_output_weights(x,delta);
				// using the learning rate and the momentum we can update the weights
				double deltaweight;
				int i=x->a_N+(x->a_BIAS!=0); // adapt the bias (weight) in the same loop
				while (--i>=0) {
					deltaweight=learning_rate*delta*x->a_inputsptr[i]; // MDH@01DEC2015: should we also multiply by the input value?????
					if (momentum>0) deltaweight+=momentum*x->a_deltaweightsptr[i];
					x->a_deltaweightsptr[i]=deltaweight;
					x->a_weightsptr[i]+=x->a_deltaweightsptr[i];
				}
			} else
				object_error((t_object *)x,"At least 2 arguments (error and learning rate) required.");
			break;
	}
}
// all proxy inlets are supposed to be able to process floats but we need to know which ones
void an_respond_to_float(t_an *x, double f) {
	int inlet_index=proxy_getinlet((t_object*)x);
	post("Inlet: %ld.",inlet_index);
	if (inlet_index==0) {
		if (x->a_l==1) { // list input allowed!!!
			// allowed in case a single input value is expected!!!
			if (x->a_N==1) { // turn it into a list, and process it as if it was a list
				t_atom atoms[1]; atom_setfloat(atoms,f);
				an_respond_to_list(x,NULL,1,atoms);
			} else
				object_error((t_object *)x,"A single input value is not allowed: expecting %ld input values.",x->a_N);
		} else { // no list input allowed
			// store this float at the first position in the input list
			x->a_inputsptr[0]=f;
			// assume input complete, so process the input
			an_process_input(x);
		}
	} else
		if (inlet_index>x->a_N)
			object_error((t_object *)x,"MdH >> At least error and learning rate are required (the third momentum argument is optional).");
		else // assumed to be an input to be stored in the corresponding inlet
	  x->a_inputsptr[inlet_index]=f;
}
//* MAIN Auto-generated by Max External Definition Editor
void ext_main(void *r) {
	// START setup
	t_class *c;
	c=class_new("an",(method)an_new,(method)an_free,(short)sizeof(t_an),NIL,A_GIMME,A_NOTHING); // allocates class memory and sets up class
	// END setup
	
	// START message handler registration
	// standard message handlers
	class_addmethod(c,(method)an_respond_to_assist,"assist",A_CANT,A_NOTHING);          // binding to assist message handler
	class_addmethod(c,(method)an_respond_to_info,"info",A_CANT,A_NOTHING);          // binding to info message handler
	class_addmethod(c,(method)an_respond_to_loadbang,"loadbang",A_CANT,A_NOTHING);          // binding to loadbang message handler
	class_addmethod(c,(method)an_respond_to_preset,"preset",A_CANT,A_NOTHING);          // binding to preset message handler
	class_addmethod(c,(method)an_respond_to_save,"save",A_CANT,A_NOTHING);          // binding to save message handler
	// specific message handlers
	class_addmethod(c,(method)an_respond_to_bang,"bang",A_NOTHING);
	// END message handler registration
	class_addmethod(c,(method)an_respond_to_float,"float",A_FLOAT,A_NOTHING);
	// MDH@01NOV2015: don't forget A_GIMME!!!
	class_addmethod(c,(method)an_respond_to_list,"list",A_GIMME,A_NOTHING);
	
	//* @TODO copy any resources here using rescopy or rescopyname
	/* SYNTAX:
	 void rescopy(OSType resType, short resID)
	 resType: The four character resource type of the resource you wish to copy.
	 resID  : The ID of the resource you wish to copy.
	 void resnamecopy(OSType resType, char *name)
	 resType: The four character resource type of the resource you wish to copy.
	 name   : A C string naming the resource you wish to copy.
	 */
	//* @TODO END
	finder_addclass("ANN","an"); // the category to put the object into
	
	class_register(CLASS_BOX,c); // add this class to the CLASS_BOX namespace
	
	srand((unsigned int)time(NULL)); // MDH@01DEC2015: initialize the random seed of the (pseudo)random number generator
	
	an_class=c; // reference to class instance
}
//* MAIN END
void an_free_weights(t_an *x) {
	if (x->a_weightsptr) sysmem_freeptr(x->a_weightsptr);
	if (x->a_inputsptr) sysmem_freeptr(x->a_inputsptr);
	if (x->a_deltaweightsptr) sysmem_freeptr(x->a_deltaweightsptr);
}
void an_initialize(t_an *x) {
	//* TODO initialization of additional x fields
	int wc=x->a_N+(x->a_BIAS!=0); // total number of weights
	if (wc>0) {
		post("MdH >> Initializing artificial neuron.");
		post("MdH >>     Number of inputs: %ld.",x->a_N);
		post("MdH >>     Function: %s.",x->a_FUNCTION->s_name);
		post("MdH >>     Bias: %ld.",x->a_BIAS);
		int i;
		x->a_weightsptr=sysmem_newptr(wc*sizeof(double));
		if (x->a_BIAS!=0) x->a_weightsptr[x->a_N]=x->a_BIAS; // it's easier to put the bias weight at the end!!!!
		post("MdH >>     Setting %ld weights to random numbers in [%f,%f].",x->a_N,x->a_MINWEIGHT,x->a_MAXWEIGHT);
		// get a random number in (MINWEIGHT,MAXWEIGHT)
		double w,wrange=x->a_MAXWEIGHT-x->a_MINWEIGHT;
		i=x->a_N; while (--i>=0) { w=x->a_MINWEIGHT; if (wrange>0) w+=rand()*wrange; x->a_weightsptr[i]=w; }
		x->a_deltaweightsptr=sysmem_newptr(wc*sizeof(double));
		i=wc; while (--i>=0) x->a_deltaweightsptr[i]=0.0;
		// we only have N inputs (not N+x->a_BIAS) but we set the last input to 1 fixed!!!
		x->a_inputsptr=sysmem_newptr(wc*sizeof(double));
		if (x->a_BIAS!=0) x->a_inputsptr[x->a_N]=1.0; // fixed value for the dummy bias input!!
	} else {
		post("MdH >> WARNING: Artificial neuron with no inputs!");
		x->a_weightsptr=NULL;
		x->a_inputsptr=NULL;
		x->a_deltaweightsptr=NULL;
	}
}
// resetting means free all memory to dynamically allocated things!!!
void an_reset(t_an *x) {
	an_free_weights(x);
	an_initialize(x);
}
//* NEW Auto-generated by Max External Definition Editor
/////////void *an_new(t_symbol *FUNCTION, long N, long M, double BIAS) {
//////void *an_new(t_symbol *FUNCTION, long N, double MINWEIGHT, double MAXWEIGHT, double BIAS, double DUMMY) {
void *an_new(t_symbol *msg, long argc, t_atom *args) {
	t_an *x; // the object to create and to be returned
	// allocate space for an instance of your class and initialize the object header
	x=(t_an *)object_alloc(an_class);
	// extract arguments, by default all the weights and biases are set to 1
	long N=1; double MINWEIGHT=1.0,MAXWEIGHT=1.0,BIAS=1.0; t_symbol *FUNCTION=gensym("L");
	///////post("Number of arguments: %ld.",args);
	x->a_l=0; // assume by default NO list input (so one inlet per input value)
	if (argc>0) {
		// if we do the function first (being a symbol), we can use l to indicate a layered artificial neuron and make it optional
		// I suppose we could do N first, because that's the most likely value to set
		N=atom_getlong(args);
		if (argc>1) {
			// the other parameters can then shift up!!!
			t_symbol *SYMBOL_ARGUMENT=atom_getsym(args+1);
			// if the second argument symbol is NOT lowercase l, we assume it's the transition function
			if (SYMBOL_ARGUMENT==gensym("l")) {
				x->a_l=1;
				if (argc>2) FUNCTION=atom_getsym(args+2); // if a function is specified get it
			} else // this argument is the function
				FUNCTION=SYMBOL_ARGUMENT; // whether or not list input!!!
			/////post("FUNCTION: %s.",FUNCTION);
			if (argc>2+x->a_l) {
				MINWEIGHT=atom_getfloat(args+(2+x->a_l));
				post("MINWEIGHT: %f.",MINWEIGHT);
				if (argc>3+x->a_l) {
					MAXWEIGHT=atom_getfloat(args+(3+x->a_l));
					//post("MAXWEIGHT: %f.",MAXWEIGHT);
					if (argc>4+x->a_l) {
						BIAS=atom_getfloat(args+(4+x->a_l));
						//post("BIAS: %f.",BIAS);
					}
				}
			}
		}
	}
	// argument processing...
	if (N<1) {
		N=1; // default
		object_error((t_object *)x,"WARNING: The number of inlet values (second argument) should always be positive, and has been set to 1.");
	}
	
	// we need to create N-1 additional proxy inlets if not a list input
	if (x->a_l==0&&N>1) { // no list input, so one float per inlet
		int i=N-1;
		x->a_proxies=sysmem_newptr(i*sizeof(void*)); // get memory to store the inlet proxy pointers
		while (--i>=0) x->a_proxies[i]=proxy_new(x,i+1,x->a_in);
	}
	
	// create the proxy for the correction inlet (apparently one for each additional inlet)
	// we're using N+1 so that it's easy to distinguish from the input inlets
	x->a_proxy=proxy_new(x,N+1,&x->a_in); // i.e. the second inlet is a proxy inlet!!!
	/*
  // START creation of additional dynamic (proxy) inlets
	 if (N>0) {
		x->a_proxies=sysmem_newptr(N*sizeof(void*)); // get memory to store the inlet proxy pointers
		int i=N; while (--i>=0) x->a_proxies[i]=proxy_new(x,i,x->a_in);
	 } else
		object_error((t_object *)x,"The number of inlet values (second argument) should always be positive.");
	 */
	// END creation of additional dynamic inlets
	// no additional inlets to create
	
	// START creation of outlets
	x->a_outlets[2]=outlet_new(x,NULL); // we'd like a message outlet (e.g. to report parameters!!!)
	x->a_outlets[1]=listout(x); // will output the error + weights (to pass to the delta generator)
	x->a_outlets[0]=floatout(x); // will output a real value
	// END creation of outlets
	
	// START process arguments
	// storing the arguments
	/// x->a_ID=ID;
	x->a_FUNCTION=FUNCTION;
	x->a_N=N;
	// if we want to be able to reset the lot we have to remember all arguments!!!
	x->a_MINWEIGHT=MINWEIGHT;
	x->a_MAXWEIGHT=MAXWEIGHT;
	x->a_BIAS=BIAS; // if a bias argument not equal to zero is defined, we will set the first weight to the bias component!!!
	// END process arguments
	
	an_initialize(x);
	
	//* TODO END
	return (x);
}
//* NEW END
//* FREE Auto-generated by Max External Definition Editor
void an_free(t_an *x) {
	//* @TODO enter memory release code here
	// how to release the proxy?????? I think it's automatic, if we declare it in a field!!!!
	an_free_weights(x);
	sysmem_freeptr(x->a_proxy);
	if (x->a_proxies) sysmem_freeptr(x->a_proxies);
	//* @TODO END
}
//* FREE END
